Das IEEE definiert Anforderungen als „Eine Bedingung oder Fähigkeit, die von einem System oder Systemkomponenten erfüllt oder besessen werden muss [\dots] (\cite{requierements}, 1990, S. 62). Diese müssen dabei korrekt, eindeutig, vollständig, konsistent, sortiert nach Wichtigkeit, verifizierbar, modifizierbar sowie rückverfolgbar sein (vgl. \cite{requierements_char}, 1998, S. 4). 
Anforderungen werden dabei meist in funktionale Anforderungen, die der Definition des IEEE folgen, als auch in nicht funktionale Anforderungen unterteilt, die sich darauf konzentrieren, wie gut die Software bestimmte Aufgaben erfüllt (vgl. \cite{nonfunctional} S. 238).

Mittels den eingeführten Begriff der Anforderungen, fokussiert sich das Kapitel nun auf die spezifischen Anforderungen des Query-Repository. Ein Schwerpunkt ist dabei sicherzustellen, das die Anforderungen dem Standard des IEEE entsprechen.
(anmerkung: Wahrscheinlich werde ich die Evaluation des Systems dann darauf beziehen, auf das verifizierbar (=Unit tests))



\section{Query-Repository Anforderungen}
Für die Beschreibung der Anforderungen wird auf die FunctionalMASTeR Anforderungsschablone der SOPHIST-Gesellschaft für Innovatives Software-Engineering zurückgegriffen welche in Abbildung \ref{fig:schablone} zu sehen ist.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\linewidth]{"../../OneDrive/masterarbeit/Analyse Kapitel/schablone"}
	\caption{ FunctionalMASTeR Anforderungsschablone (todo: Buch ausleihen Requirements-Engineering und -Management)}
	\label{fig:schablone}
\end{figure}
\newline
Die Wörter \textbf{muss} (verpflichtend), \textbf{sollte} (wünschenswert) und \textbf{wird} (zukünftig) stellen dabei die Verbindlichkeit der Anforderungen da. 
Das Wort \textbf{System} wird mit dem Begriff des zu entwickelten Systems ersetzt.
Im nächsten Schritt wird die Art der Funktionalität beschrieben. Die \textbf{Möglichkeit bieten} stellt dabei eine Benutzeraktion da, während ein \textbf{fähig sein} eine Schnittstellenanforderung darstellt bzw. ein Prozess, der in Abhängigkeit von einem Fremdsystem gestartet wird. Sofern es sich weder um das eine noch andere handelt, kann der Baustein weggelassen werden, um eine selbstständige Systemaktivität darzustellen. im nächsten Schritt wird das \textbf{Objekt} genauer spezifiziert, für das die Funktionalität gefordert wird. Am ende steht dann das \textbf{Prozesswort}, welche die Funktionalität beschreibt die das System ausführen wird. 
Abschließen kann, wie in Schritt fünf erkenntlich, eine Bedingung z.B. eine zeitliche oder logische als Nebensatz genutzt werden, um genauer zu spezifizieren, wann die Funktionalität ausgeführt werden muss. (vgl todo buch) 

Bei Anforderungen im Query-Repository, die genauer Beschrieben müssen, gibt es ergänzend die detaillierte FunctionalMASTeR Anforderungsschablone, wie sie in Abbildung \ref{fig:detailierteschablone} zu sehen ist. Der Unterschied dabei ist, dass sowohl das Objekt als auch das Prozesswort genauer spezifiziert werden.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{"../../OneDrive/masterarbeit/Analyse Kapitel/detailierte_schablone"}
	\caption{ detaillierte FunctionalMASTeR Anforderungsschablone (todo: Buch ausleihen Requirements-Engineering und -Management) }
	\label{fig:detailierteschablone}
\end{figure}



\begin{enumerate}
\item  Das Query-Repository muss fähig sein, vom Optimierer empfangene Datenbankabfragen und deren Zeitstempel zu archivieren.
\label{1}
\item  Das Query-Repository muss fähig sein, vom Optimierer empfangene Ausführungspläne und deren Zeitstempel zu archivieren.
\label{2}
\item  Das Query-Repository muss zu einem empfangen Ausführungsplan die dazugehörigen Kostenmodell, die zu dem Ausführungsplan geführt haben abspeichern.
\label{111}
\item  Das Query-Repository muss zu einem empfangen Ausführungsplan die dazugehörigen RPU Capabilities, die zu dem Ausführungsplan geführt haben abspeichern.
\label{112}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten, ein Verlauf aller archivierten Datenbankabfragen anzuzeigen.
\label{3}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten, den Verlauf aller archivierten Datenbankabfragen nach Zeiträumen filtern zu lassen. 
\label{4}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten, den Verlauf aller archivierten Datenbankabfragen nach deren referenzierten Tabellen innerhalb einer Datenbankabfrage filtern zu lassen.
\label{5}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit geben, zu einer Datenbankabfrage den dazugehörigen Ausführungsplan auszugeben. 
\label{9}
\item  Falls es zu einer Datenbankabfrage, die der Nutzer gestellt hat, mehrere Ausführungspläne gibt, muss das Query-Repository alle weiteren Ausführungspläne ausgeben.\label{90}



\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten, eigene Datenbankabfragen schreiben zu lassen.
\label{6}
\item  Das Query-Repository muss fähig sein, empfangene Datenbankabfragen vom Nutzer an das Gateway weiterzuleiten.
\label{7}
\item  Sobald das Query-Repository den Ausführungsplan zu der gesendeten Datenbankabfrage des Nutzers erhält, muss das System den Ausführungsplan den Nutzer anzeigen.	
\label{8}



\item  Das Query-Repository muss dem Nutzer die Möglichkeit geben, 
zu einem Ausführungsplan die dazugehörigen RPU Capabilities eines Geräts und deren Operatorentyp anzuzeigen.
\label{10}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit geben, 
zu einem Ausführungsplan die dazugehörigen Kostenmodelle eines Geräts und deren Operatorentyp anzuzeigen.
\label{11}


\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten ein Gerät bestehend aus Name,Ports, IP, Kostenplan und RPU Capabilities erstellen zu lassen.
\label{12}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten  Ports für ein Gerät zu erstellen.
\label{13}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten die Ports eines Geräts zu aktualisieren.        
\label{14}
\item  Das Query-Repository muss fähig sein dem Optimierer eine Gerätekonfiguration zu zusenden.

\label{15}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten den Kostenplan eines Geräts zu aktualisieren
\label{16}
\item  Das Query-Repository muss nicht mehr aktive Kostenpläne eines Geräts 
versionieren.
\label{17}
\item  Das Query-Repository muss dem Nutzer die Möglichkeit bieten die RPU Capabilities eines Geräts zu aktualisieren
\label{18}
\item  Das Query-Repository muss mehr aktive RPU Capabilities eines Geräts versionieren.
\label{19}
\item  das Query-Repository muss dem Nutzer die Möglichkeit geben alle konfigurierten Geräte anzuzeigen.
\label{20}

\item  das Query-Repository muss dem Nutzer die Möglichkeit geben Datenstreams zu definieren.
\label{21}

\item  das Query-Repository muss dem Nutzer die Möglichkeit geben einem Port einen Datenstream zu zuweisen.
\label{22}


\item  Das Query-Repository soll automatisch neu eingetroffene Datenbankabfragen dem Nutzer zeigen.\label{211}


\item  Das Query-Repository wird fähig sein Gerätekonfigurationen in Echtzeit Gerätekonfigurationen dem Optimierer zu zusenden. \label{212}

  
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[height=0.7\linewidth]{"../../OneDrive/masterarbeit/Analyse Kapitel/use_case.drawio"}
	\caption{Die Anforderungen in einem Anwendungsfalldiagramm vereint}
	\label{fig:usecase}
\end{figure}


